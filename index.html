<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPG's Aisle Dash</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* BASE STYLES (AESTHETICS) */
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0d1a26; /* Dark Blue Background */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            color: #ffffff; /* White Text */
            min-height: 100vh;
            padding: 10px; /* Added for mobile edges */
            box-sizing: border-box;
        }
        
        .container {
            background-color: #1a334c; /* Medium Blue Container */
            padding: 1.5rem 1rem; /* Adjusted padding for mobile */
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); /* Red Glow Shadow */
            text-align: center;
            width: 100%; /* Maximize width */
            max-width: 1100px; 
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Responsive Title Size */
        h1 {
            color: #FF0000; 
            margin-bottom: 1rem;
            font-size: 1.8rem; /* Mobile optimized size */
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
        }
        
        #game-info {
            display: flex;
            justify-content: space-between;
            padding: 0 0.5rem;
            width: 100%;
            margin-bottom: 1rem;
        }

        #lives-display, #score-display {
            font-size: 1.1rem; /* Smaller for mobile layout */
            font-weight: bold;
        }
        
        #lives-display { color: #FF6347; }
        #score-display { color: #00BFFF; }
        
        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem; /* Reduced gap */
        }
        
        #instruction {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 0.25rem;
        }
        
        /* Summary text adjusted for size */
        #summary-text {
            font-size: 0.85rem; 
            line-height: 1.4;
            color: #ffffff; 
            margin-bottom: 0.75rem;
            text-align: left; /* Make rules readable */
        }
        #summary-text p { margin: 0.4rem 0; }

        .red-bold {
            font-weight: 700;
            color: #FF0000;
        }

        /* --- FEEDBACK/COMPARISON STYLES --- */
        .feedback-title {
            font-size: 1.4rem; /* Adjusted for mobile */
        }
        
        .success-message {
            color: #32CD32; 
            text-shadow: 0 0 10px #32CD32, 0 0 20px #32CD32;
        }
        
        .failure-message {
            color: #FF0000; 
            text-shadow: 0 0 10px #FF0000, 0 0 20px #FF0000;
        }

        .results-container {
            width: 100%;
            margin-top: 1rem;
            gap: 0.75rem;
            display: flex; /* FIX: Enable flex for the results container */
            flex-direction: column;
        }

        .result-row {
            padding: 0.5rem;
            /* FIX: Ensure result rows are also flex containers for horizontal layout */
            display: flex; 
            flex-direction: column; 
            align-items: center;
            border: 2px solid #00BFFF;
            border-radius: 8px;
            background-color: #0f2238;
        }

        .result-row h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            margin-top: 0;
        }
        
        .item-list-row {
            gap: 0.5rem; /* Tighter gap for mobile */
            overflow-x: auto; /* Allow horizontal scroll if needed */
            
            /* CRITICAL FIX: Ensure inner list items are also flex */
            display: flex; 
            flex-wrap: nowrap; /* Keep items in a row */
            justify-content: center;
        }
        /* --- END FEEDBACK/COMPARISON STYLES --- */
        
        #timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #FF6347;
        }
        
        /* Main game container for memorization/reordering */
        #item-list, #reorder-list {
            display: flex;
            justify-content: center; 
            padding: 0.75rem; /* Reduced padding */
            border: 3px dashed #00BFFF;
            border-radius: 10px;
            width: 100%;
            min-height: 110px; /* Reduced min height */
            box-sizing: border-box;
            transition: opacity 0.5s ease-in-out;
            gap: 0.5rem; /* Gap between items */
            
            flex-wrap: nowrap; /* Keep items in a row */
            overflow-x: auto; /* Critical for when many items are present */
            -webkit-overflow-scrolling: touch;
        }
        
        #reorder-list {
            display: none;
        }

        .item {
            /* Changed cursor to grab/pointer to indicate interactivity */
            cursor: grab; 
            padding: 0.3rem;
            border: 2px solid #00BFFF; 
            border-radius: 8px;
            background-color: #2e4a6a; 
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-weight: bold;
            position: relative;
            text-align: center; 
            
            /* Fluid sizing for items, allowing them to shrink but having a minimum target size */
            flex: 0 0 auto; 
            min-width: 75px; /* Minimum width for touch target */
            max-width: 100px; 
            box-sizing: border-box;
        }
        
        /* Image styles */
        .item-icon {
            /* FIX: Make image smaller than the container to allow padding/centering */
            max-width: 90%; 
            max-height: 90%;
            object-fit: contain;
            /* FIX: Center the image within its wrapper */
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Style for the image wrapper/fallback container */
        .item-image-wrapper {
            width: 100%; 
            height: 70px; 
            display: block;
            position: relative;
            background-color: #4b6b8b; /* Solid color fallback */
            border-radius: 4px;
        }

        .item.dragging {
            opacity: 0.8;
            transform: scale(1.1); /* Slightly larger scale for better touch visibility */
            box-shadow: 0 0 15px #FF0000;
            position: absolute; /* Take out of flow while dragging (Crucial for touch) */
            z-index: 1000; 
        }
        
        /* Placeholder for where the dragging item was */
        .item-placeholder {
            /* Match the size of the item */
            width: 75px; 
            min-height: 70px; 
            border: 3px dashed #FF6347;
            border-radius: 8px;
            margin: 0 0.5rem;
            flex: 0 0 auto;
        }

        .item.correct { background-color: #1E90FF; border-color: #FFFFFF; }
        .item.incorrect { background-color: #FF0000; border-color: #FFFFFF; }

        button {
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: #ffffff;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background-color: #00BFFF;
        }
        
        .play-button {
            padding: 1.2rem 3rem; 
            font-size: 1.6rem;
            background-color: #32CD32;
            box-shadow: 0 0 15px rgba(50, 205, 50, 0.7);
        }

        .play-button:hover {
            background-color: #2cba2c;
            box-shadow: 0 0 20px rgba(50, 205, 50, 1.0);
        }

        button:hover {
            background-color: #1E90FF;
            box-shadow: 0 0 10px #00BFFF;
        }

        /* Score animation */
        .score-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem; 
            font-weight: bold;
            color: #32CD32;
            animation: fade-up 1.5s forwards;
            pointer-events: none;
            text-shadow: 0 0 15px #32CD32;
            z-index: 1001;
        }

        @keyframes fade-up {
            0% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, -150%); opacity: 0; }
        }
        
        /* Ensure touch devices use the grab cursor, or default to pointer */
        @media (pointer: coarse) {
            .item {
                cursor: grab;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>ðŸ›’ FPG's Aisle Dash ðŸ›’</h1>
        <div id="game-info">
            <div id="lives-display"></div>
            <div id="score-display"></div>
        </div>
        <div id="game-area">
            <div id="instruction"></div>
            
            <div id="summary-text">
                <p><strong>Rules:</strong></p>
                <p>
                    1. <span class="red-bold">Memorize</span> the sequence of items in 8 seconds.
                </p>
                <p>
                    2. <span class="red-bold">Reorder</span> the scrambled items into the correct sequence by dragging and dropping in 15 seconds or less.
                </p>
                <p>
                    3. <span class="red-bold">Win</span> by reordering correctly, the faster, the more points! You have <span class="red-bold">3 lives</span>!
                </p>
            </div>
            
            <div id="timer"></div>
            <div id="item-list"></div> 
            
            <button id="start-button" class="play-button">PLAY</button>
            
            <div id="reorder-list"></div>
            <button id="submit-button" style="display: none;">Submit Order</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- UPDATED IMAGE REFERENCES ---
            const items = [
                { name: 'Milk', src: '13202316_XL1_20211008-removebg-preview.PNG' },
                { name: 'Eggs', src: '11046848_XL1-removebg-preview.PNG' },
                { name: 'Bread', src: '13218895_XL1_20220805-removebg-preview.PNG' },
                { name: 'Cheese', src: '13179364_XL1_20250128-removebg-preview.PNG' },
                { name: 'Cereal', src: '10045587_XL1_20201012-removebg-preview.PNG' },
                { name: 'Apple', src: '13242536_XL1_20251022-removebg-preview.PNG' },
                { name: 'Soap', src: '432823_XL1_20210504-removebg-preview.PNG' },
                { name: 'Coffee', src: '13267810_XL1_20250423-removebg-preview.PNG' },
                { name: 'Water', src: '13271014_XL1_20250703-removebg-preview.PNG' },
                { name: 'Potato', src: '13259518_XL1_20250217-removebg-preview.PNG' },
                { name: 'Carrot', src: '13241559_XL1_20250201-removebg-preview.PNG' },
                { name: 'Donut', src: '13227361_XL1_20221123-removebg-preview.PNG' },
            ];
            // --- END UPDATED IMAGE REFERENCES ---

            const uniqueItems = items; 

            // --- UPDATED createImageItem: Image Only, No Visible Text Fallback ---
            function createImageItem(item) {
                // Main wrapper for the image and fallback background
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'item-image-wrapper'; 
                
                const img = document.createElement('img');
                img.src = item.src;
                img.alt = item.name;
                img.className = 'item-icon';
                
                // If image loads successfully, add it to the wrapper.
                img.onload = function() {
                    imageWrapper.appendChild(img);
                };
                
                // If image fails to load (missing file), do nothing; the wrapper's background color acts as the fallback.
                img.onerror = function() {
                    console.warn(`Missing image file for: ${item.name} (${item.src}). Showing solid color fallback.`);
                    // We don't append the image, so only the background color remains visible.
                };
                
                // Attempt to load the image immediately
                imageWrapper.appendChild(img);
                
                return imageWrapper;
            }
            // --- END UPDATED createImageItem ---


            let originalSequence = [];
            let timer;
            let currentLevel = 0;
            let totalScore = 0;
            let lives = 3;
            let startTime;
            let levelItemsCount = 3; 
            
            // Touch state variables
            let draggingItem = null;
            let placeholder = null;
            let activeList = null; 

            // --- FIXED TIME CONSTANTS ---
            const FIXED_THINK_TIME_MS = 8000;
            const FIXED_ORDER_TIME_S = 15;
            const SCORE_PER_SECOND_BONUS = 5;

            const instruction = document.getElementById('instruction');
            const timerDisplay = document.getElementById('timer');
            const startButton = document.getElementById('start-button');
            const submitButton = document.getElementById('submit-button');
            const itemListContainer = document.getElementById('item-list');
            const reorderListContainer = document.getElementById('reorder-list');
            const scoreDisplay = document.getElementById('score-display');
            const livesDisplay = document.getElementById('lives-display');
            const summaryText = document.getElementById('summary-text'); 
            
            function initializeGame() {
                totalScore = 0;
                lives = 3;
                currentLevel = 0;
                levelItemsCount = 3;
                
                summaryText.style.display = 'none';
                startButton.classList.remove('play-button');
                
                reorderListContainer.style.display = 'none'; 
                itemListContainer.style.display = 'flex';
                updateDisplay();
                startGame();
            }

            function updateDisplay() {
                livesDisplay.textContent = `Lives: ${lives}`;
                scoreDisplay.textContent = `Score: ${totalScore.toFixed(0)}`;
            }

            function startGame() {
                startButton.style.display = 'none';
                
                const levelConfig = {
                    items: levelItemsCount,
                    displayTime: FIXED_THINK_TIME_MS, 
                    sortTime: FIXED_ORDER_TIME_S
                };
                
                let selectedItems = [];

                if (startButton.textContent === 'Retry Level') {
                    // Find items based on the names in the previous originalSequence
                    selectedItems = originalSequence.map(name => 
                        uniqueItems.find(item => item.name === name)
                    );
                } else {
                    // Normal start or Next Level: get new random items and update originalSequence
                    selectedItems = getRandomItems(levelConfig.items);
                    originalSequence = selectedItems.map(item => item.name);
                }

                displayList(selectedItems, levelConfig.displayTime);
            }

            function getRandomItems(count) {
                const shuffled = [...uniqueItems].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            function displayList(list, displayTime) {
                instruction.textContent = "Level " + (currentLevel + 1) + ": Memorize the sequence!";
                itemListContainer.innerHTML = '';
                itemListContainer.style.border = '3px dashed #00BFFF';
                
                list.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.appendChild(createImageItem(item)); 
                    itemListContainer.appendChild(itemDiv);
                });

                timerDisplay.textContent = `Time left: ${FIXED_THINK_TIME_MS / 1000}s`;
                let timeLeft = FIXED_THINK_TIME_MS / 1000;
                let displayTimer = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = `Time left: ${timeLeft}s`;
                    if (timeLeft <= 0) {
                        clearInterval(displayTimer);
                        startMemoryPhase(list);
                    }
                }, 1000);
            }
            
            function getGuaranteedScrambledItems(originalList) {
                let scrambledList;
                let isScrambled = false;

                if (originalList.length <= 1) {
                     return originalList; 
                }

                while (!isScrambled) {
                    scrambledList = [...originalList].sort(() => 0.5 - Math.random());
                    // Must contain at least one difference
                    isScrambled = scrambledList.some((item, index) => item.name !== originalList[index].name);
                }
                return scrambledList;
            }


            function startMemoryPhase(list) {
                instruction.textContent = "Now, reorder the items!";
                itemListContainer.style.display = 'none';
                reorderListContainer.style.display = 'flex'; 
                reorderListContainer.innerHTML = '';
                reorderListContainer.style.overflowX = 'auto'; // Re-enable scroll if needed

                const scrambledItems = getGuaranteedScrambledItems(list);
                
                scrambledItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.draggable = true; // Keep for desktop drag/drop
                    itemDiv.dataset.name = item.name;
                    itemDiv.appendChild(createImageItem(item)); 
                    reorderListContainer.appendChild(itemDiv);
                });

                setupDesktopDragAndDrop();
                setupTouchControls(); // Set up touch for mobile
                submitButton.style.display = 'block';
                
                startTime = Date.now();
                let sortTimeLeft = FIXED_ORDER_TIME_S; 
                timerDisplay.textContent = `Sort time: ${sortTimeLeft}s`;
                timer = setInterval(() => {
                    sortTimeLeft--;
                    timerDisplay.textContent = `Sort time: ${sortTimeLeft}s`;
                    if (sortTimeLeft <= 0) {
                        clearInterval(timer);
                        checkOrder();
                    }
                }, 1000);
            }
            
            // --- DESKTOP/MOUSE DRAG LOGIC ---
            function setupDesktopDragAndDrop() {
                const listItems = document.querySelectorAll('#reorder-list .item');
                let draggingItem = null;

                // Desktop Drag & Drop (Still valid for mouse users)
                listItems.forEach(item => {
                    item.addEventListener('dragstart', () => {
                        draggingItem = item;
                        // Use setTimeout to ensure the dragging class is applied after drag event is initiated
                        setTimeout(() => item.classList.add('dragging'), 0); 
                    });

                    item.addEventListener('dragend', () => {
                        if (draggingItem) {
                            draggingItem.classList.remove('dragging');
                        }
                        draggingItem = null;
                    });
                });

                reorderListContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    // This function is reused to find the insertion point for both mouse and touch
                    const afterElement = getDragAfterElement(reorderListContainer, e.clientY, e.clientX); 
                    const draggable = document.querySelector('.dragging');
                    
                    if (draggable && !draggable.touchDragging) { // Exclude touch-dragged items from mouse events
                        if (afterElement == null) {
                            reorderListContainer.appendChild(draggable);
                        } else {
                            reorderListContainer.insertBefore(draggable, afterElement);
                        }
                    }
                });
            }
            
            // --- CRITICAL MOBILE TOUCH LOGIC ---

            function setupTouchControls() {
                activeList = reorderListContainer;
                const items = activeList.querySelectorAll('.item');
                
                // Ensure existing listeners are removed before adding new ones
                items.forEach(item => {
                    item.removeEventListener('touchstart', handleTouchStart);
                    item.removeEventListener('touchmove', handleTouchMove);
                    item.removeEventListener('touchend', handleTouchEnd);
                    
                    item.addEventListener('touchstart', handleTouchStart, { passive: false });
                    item.addEventListener('touchmove', handleTouchMove, { passive: false });
                    item.addEventListener('touchend', handleTouchEnd);
                });
            }

            function handleTouchStart(e) {
                // Only handle single touch for dragging
                if (e.touches.length > 1 || draggingItem) return;
                
                e.preventDefault(); 
                
                // 1. Setup Item State
                draggingItem = e.currentTarget;
                draggingItem.classList.add('dragging');
                draggingItem.touchDragging = true; // Flag to differentiate from desktop drag

                // 2. Create Placeholder
                placeholder = document.createElement('div');
                placeholder.className = 'item-placeholder';
                activeList.insertBefore(placeholder, draggingItem.nextSibling);

                // 3. Calculate Offsets for Absolute Positioning
                const touch = e.touches[0];
                const rect = draggingItem.getBoundingClientRect();
                
                // Store offset from touch point to item top-left corner
                draggingItem.offsetX = touch.clientX - rect.left;
                draggingItem.offsetY = touch.clientY - rect.top;

                // 4. Apply Initial Absolute Position
                draggingItem.style.position = 'absolute';
                // Adjust position based on scroll to ensure it stays anchored to the touch point
                draggingItem.style.left = `${touch.clientX - draggingItem.offsetX}px`;
                draggingItem.style.top = `${touch.clientY - draggingItem.offsetY}px`;
                
                // 5. Temporarily disable the list container's horizontal scroll
                activeList.style.overflowX = 'hidden'; 
            }

            function handleTouchMove(e) {
                if (!draggingItem || !draggingItem.touchDragging) return;
                
                // FIX 3: Prevent default scrolling behavior during touch move
                e.preventDefault(); 
                
                const touch = e.touches[0];
                
                // 1. Update absolute position of the dragging item
                draggingItem.style.left = `${touch.clientX - draggingItem.offsetX}px`;
                draggingItem.style.top = `${touch.clientY - draggingItem.offsetY}px`;
                
                // 2. Find where to insert the placeholder
                const afterElement = getDragAfterElement(activeList, touch.clientY, touch.clientX);
                
                if (afterElement == null) {
                    activeList.appendChild(placeholder);
                } else {
                    activeList.insertBefore(placeholder, afterElement);
                }
            }

            function handleTouchEnd(e) {
                if (!draggingItem || !draggingItem.touchDragging) return;

                // 1. Final insertion: insert the dragging item where the placeholder is
                activeList.insertBefore(draggingItem, placeholder);
                
                // 2. Clean up styles and state
                draggingItem.classList.remove('dragging');
                draggingItem.touchDragging = false;
                draggingItem.style.position = '';
                draggingItem.style.left = '';
                draggingItem.style.top = '';
                
                // 3. Remove placeholder
                if (placeholder) {
                    placeholder.remove();
                    placeholder = null;
                }
                draggingItem = null;
                
                // 4. Re-enable scroll
                activeList.style.overflowX = 'auto'; 
            }
            
            // Finds the element to insert after based on X-position
            function getDragAfterElement(container, y, x) {
                // Find visible items that are not the placeholder or the item currently being dragged
                const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')]
                    .filter(el => el !== placeholder);
                
                // Find the closest item horizontally
                const closest = draggableElements.reduce((closest, child) => {
                    const rect = child.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const distance = Math.abs(x - centerX); 

                    if (distance < closest.distance) {
                        return { distance: distance, element: child };
                    }
                    return closest;
                }, { distance: Infinity, element: null });
                
                if (closest.element === null) {
                    return null;
                }

                const child = closest.element;
                const rect = child.getBoundingClientRect();
                const itemMidX = rect.left + rect.width / 2;
                
                // If touch/mouse X is past the middle of the element, insert after it
                if (x > itemMidX) {
                    return child.nextElementSibling;
                } else {
                    return child; // Insert before it
                }
            }
            // --- END CRITICAL MOBILE TOUCH LOGIC ---


            function buildItemRow(sequence, isCorrectRow, highlightCorrect = false) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'item-list-row';

                sequence.forEach((name, index) => {
                    const itemConfig = uniqueItems.find(i => i.name === name);
                    const itemDiv = document.createElement('div');
                    
                    let isItemCorrect = highlightCorrect && (name === originalSequence[index]);
                    
                    if (!isCorrectRow && highlightCorrect) {
                        itemDiv.className = `item ${isItemCorrect ? 'correct' : 'incorrect'}`;
                    } else if (isCorrectRow) {
                        itemDiv.className = 'item correct';
                    } else {
                        itemDiv.className = 'item incorrect';
                    }

                    itemDiv.appendChild(createImageItem(itemConfig));
                    rowDiv.appendChild(itemDiv);
                });
                return rowDiv;
            }


            function checkOrder() {
                clearInterval(timer);
                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                
                const finalOrder = [...reorderListContainer.children].map(item => item.dataset.name);
                let correctCount = 0;
                
                finalOrder.forEach((item, index) => {
                    if (item === originalSequence[index]) {
                        correctCount++;
                    }
                });
                
                // Disable touch handling
                const items = reorderListContainer.querySelectorAll('.item');
                items.forEach(item => {
                    item.removeEventListener('touchstart', handleTouchStart);
                    item.removeEventListener('touchmove', handleTouchMove);
                    item.removeEventListener('touchend', handleTouchEnd);
                });

                submitButton.style.display = 'none';
                itemListContainer.innerHTML = '';
                reorderListContainer.style.display = 'none';

                if (correctCount === originalSequence.length) {
                    const timeBonus = Math.max(0, FIXED_ORDER_TIME_S - timeTaken);
                    const scoreThisRound = 100 + timeBonus * SCORE_PER_SECOND_BONUS;
                    totalScore += scoreThisRound;

                    updateDisplay(); 

                    // SUCCESS FEEDBACK
                    instruction.className = 'feedback-title success-message';
                    instruction.textContent = "Cart Filled Successfully!";
                    timerDisplay.textContent = `Score Bonus: +${(timeBonus * SCORE_PER_SECOND_BONUS).toFixed(0)}`;
                    
                    showScorePopup(document.querySelector('.container'), "SUCCESS"); 
                    
                    setTimeout(() => {
                        itemListContainer.style.display = 'flex';
                        itemListContainer.style.border = 'none';
                        
                        const successRowContainer = document.createElement('div');
                        successRowContainer.className = 'item-list-row';
                        successRowContainer.style.gap = '0.5rem'; /* Use smaller gap for success view */

                        originalSequence.forEach(name => {
                            const itemConfig = uniqueItems.find(i => i.name === name);
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'item correct';
                            itemDiv.appendChild(createImageItem(itemConfig));
                            successRowContainer.appendChild(itemDiv);
                        });
                        
                        itemListContainer.appendChild(successRowContainer);

                        if (levelItemsCount < uniqueItems.length) {
                            levelItemsCount++;
                            currentLevel++;
                            startButton.textContent = 'Next Level';
                            startButton.style.display = 'block';
                        } else {
                            instruction.textContent = "You Win! Final Score: " + totalScore.toFixed(0);
                            timerDisplay.textContent = '';
                            startButton.textContent = 'Play Again';
                            startButton.style.display = 'block';
                        }
                    }, 2000); 
                    
                } else {
                    lives--;
                    updateDisplay();
                    
                    // FAILURE FEEDBACK
                    instruction.className = 'feedback-title failure-message';
                    instruction.textContent = "Cart Filled Unsuccessfully";
                    timerDisplay.textContent = `Lives remaining: ${lives}`;
                    
                    const resultsContainer = document.createElement('div');
                    resultsContainer.className = 'results-container'; 
                    
                    // 1. YOUR CART (User's Incorrect Order)
                    const yourCartDiv = document.createElement('div');
                    yourCartDiv.className = 'result-row';
                    yourCartDiv.innerHTML = '<h3>Your Cart</h3>';
                    yourCartDiv.appendChild(buildItemRow(finalOrder, false, true)); 
                    resultsContainer.appendChild(yourCartDiv);

                    // 2. RIGHT CART (Correct Order)
                    const rightCartDiv = document.createElement('div');
                    rightCartDiv.className = 'result-row';
                    rightCartDiv.innerHTML = '<h3>Right Cart</h3>';
                    rightCartDiv.appendChild(buildItemRow(originalSequence, true));
                    resultsContainer.appendChild(rightCartDiv);

                    itemListContainer.style.display = 'flex';
                    itemListContainer.style.border = 'none';
                    itemListContainer.appendChild(resultsContainer);
                    
                    if (lives <= 0) {
                        instruction.textContent = "Game Over!";
                        timerDisplay.textContent = `Final Score: ${totalScore.toFixed(0)}`;
                        startButton.textContent = 'Play Again';
                        startButton.style.display = 'block';
                    } else {
                        startButton.textContent = 'Retry Level';
                        startButton.style.display = 'block';
                    }
                }
            }

            function showScorePopup(element, text) {
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = text;
                element.appendChild(popup);

                popup.addEventListener('animationend', () => {
                    popup.remove();
                });
            }

            startButton.addEventListener('click', () => {
                instruction.className = '';
                
                startButton.classList.remove('play-button'); 

                if(startButton.textContent === 'Play Again') {
                    initializeGame();
                } else if(startButton.textContent === 'Next Level' || startButton.textContent === 'Retry Level') {
                    document.getElementById('game-area').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('game-area').style.opacity = '1';
                        startGame();
                    }, 500);
                } else {
                    initializeGame();
                }
            });

            submitButton.addEventListener('click', checkOrder);

            // INITIALIZATION
            updateDisplay();
            instruction.textContent = "Welcome to FPG's Aisle Dash!";
            timerDisplay.textContent = '';
            
            // Set initial state visibility
            summaryText.style.display = 'block';
            itemListContainer.style.display = 'none'; // Hide the item box until game starts
            reorderListContainer.style.display = 'none';
            startButton.style.display = 'block';

        });
    </script>
</body>
</html>
