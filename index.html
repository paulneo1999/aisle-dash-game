<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>FPG's Aisle Dash</title>
    
    <link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700&display=swap" rel="stylesheet">
    
    <style>
        /* BASE STYLES (AESTHETICS) */
        body {
            font-family: 'Orbitron', sans-serif;
            background-color: #0d1a26; /* Dark Blue Background */
            display: flex;
            justify-content: center;
            align-items: center;
            flex-direction: column;
            margin: 0;
            color: #ffffff; /* White Text */
            min-height: 100vh;
            padding: 10px; /* Added for mobile edges */
            box-sizing: border-box;
        }
        
        .container {
            background-color: #1a334c; /* Medium Blue Container */
            padding: 1.5rem 1rem; /* Adjusted padding for mobile */
            border-radius: 10px;
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5); /* Red Glow Shadow */
            text-align: center;
            width: 100%; /* Maximize width */
            max-width: 1100px; 
            position: relative;
            overflow: hidden;
            box-sizing: border-box;
        }

        /* Responsive Title Size */
        h1 {
            color: #FF0000; 
            margin-bottom: 1rem;
            font-size: 1.8rem; /* Mobile optimized size */
            text-shadow: 0 0 5px rgba(255, 0, 0, 0.7);
        }
        
        #game-info {
            display: flex;
            justify-content: space-between;
            padding: 0 0.5rem;
            width: 100%;
            margin-bottom: 1rem;
        }

        #lives-display, #score-display {
            font-size: 1.1rem; /* Smaller for mobile layout */
            font-weight: bold;
        }
        
        #lives-display { color: #FF6347; }
        #score-display { color: #00BFFF; }
        
        #game-area {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.75rem; /* Reduced gap */
        }
        
        #instruction {
            font-size: 1.1rem;
            font-weight: bold;
            color: #ffffff;
            margin-bottom: 0.25rem;
        }
        
        /* Summary text adjusted for size */
        #summary-text {
            font-size: 0.85rem; 
            line-height: 1.4;
            color: #ffffff; 
            margin-bottom: 0.75rem;
            text-align: left; /* Make rules readable */
        }
        #summary-text p { margin: 0.4rem 0; }

        .red-bold {
            font-weight: 700;
            color: #FF0000;
        }

        /* --- FEEDBACK/COMPARISON STYLES --- */
        .feedback-title {
            font-size: 1.4rem; /* Adjusted for mobile */
        }
        
        .success-message {
            color: #32CD32; 
            text-shadow: 0 0 10px #32CD32, 0 0 20px #32CD32;
        }
        
        .failure-message {
            color: #FF0000; 
            text-shadow: 0 0 10px #FF0000, 0 0 20px #FF0000;
        }

        .results-container {
            width: 100%;
            margin-top: 1rem;
            gap: 0.75rem;
            display: flex; 
            flex-direction: column;
        }

        .result-row {
            padding: 0.5rem;
            display: flex; 
            flex-direction: column; 
            align-items: center;
            border: 2px solid #00BFFF;
            border-radius: 8px;
            background-color: #0f2238;
        }

        .result-row h3 {
            font-size: 1rem;
            margin-bottom: 0.5rem;
            margin-top: 0;
        }
        
        .item-list-row {
            gap: 0.5rem; 
            overflow-x: auto; 
            display: flex; 
            flex-wrap: nowrap; 
            justify-content: center;
        }
        /* --- END FEEDBACK/COMPARISON STYLES --- */
        
        #timer {
            font-size: 1.5rem;
            font-weight: bold;
            color: #FF6347;
        }
        
        /* Main game container for memorization/reordering */
        #item-list, #reorder-list {
            display: flex;
            justify-content: center; 
            padding: 0.75rem; 
            border: 3px dashed #00BFFF;
            border-radius: 10px;
            width: 100%;
            min-height: 110px; 
            box-sizing: border-box;
            transition: opacity 0.5s ease-in-out;
            gap: 0.5rem; 
            
            flex-wrap: nowrap; 
            overflow-x: auto; 
            -webkit-overflow-scrolling: touch;
        }
        
        /* === NEW SCROLLBAR STYLES === */

        /* Apply custom scrollbar to all lists that may scroll horizontally */
        #item-list, #reorder-list, .item-list-row {
            scrollbar-color: #FF0000 #1a334c; /* Firefox scrollbar color (thumb track) */
            scrollbar-width: thin; /* Firefox scrollbar thickness */
        }

        /* WebKit (Chrome, Safari) Scrollbar Styling */
        #item-list::-webkit-scrollbar, 
        #reorder-list::-webkit-scrollbar, 
        .item-list-row::-webkit-scrollbar {
            height: 10px; /* Thicker scrollbar */
        }

        /* Scrollbar Track (the background) */
        #item-list::-webkit-scrollbar-track, 
        #reorder-list::-webkit-scrollbar-track, 
        .item-list-row::-webkit-scrollbar-track {
            background: #1a334c; /* Matches container background */
            border-radius: 10px;
        }

        /* Scrollbar Thumb (the draggable part) */
        #item-list::-webkit-scrollbar-thumb, 
        #reorder-list::-webkit-scrollbar-thumb, 
        .item-list-row::-webkit-scrollbar-thumb {
            background-color: #FF0000; /* Bright Red */
            border-radius: 10px;
            border: 2px solid #0d1a26; /* Dark border for contrast */
        }

        #item-list::-webkit-scrollbar-thumb:hover, 
        #reorder-list::-webkit-scrollbar-thumb:hover, 
        .item-list-row::-webkit-scrollbar-thumb:hover {
            background-color: #FF6347; /* Lighter red on hover */
        }
        /* === END SCROLLBAR STYLES === */


        /* === Responsive Wrap CSS === */
        
        /* This rule forces items to fit on one line as long as possible. */
        .item {
            cursor: grab; 
            padding: 0.3rem;
            border: 2px solid #00BFFF; 
            border-radius: 8px;
            background-color: #2e4a6a; 
            transition: transform 0.2s ease-in-out, box-shadow 0.2s ease-in-out;
            user-select: none;
            display: flex;
            flex-direction: column;
            align-items: center;
            font-weight: bold;
            position: relative;
            text-align: center; 
            
            flex: 0 0 10%; /* NEW: Base width is 10% (10 cards fit a row) */
            min-width: 75px; /* Minimum size to keep items usable */
            max-width: 100px; 
            box-sizing: border-box;
            
            margin-bottom: 0.5rem; 
        }

        /* ---------------------------------------------------- */
        /* RULE 1: FOR SINGLE ROW (Less than 9 items) - Allows shrinking but scroll only if necessary */
        /* ---------------------------------------------------- */

        /* ---------------------------------------------------- */
        /* RULE 2: FOR MULTI-ROW (9 items or more) - Forces wrapping and removes horizontal scroll */
        /* ---------------------------------------------------- */
        @media (max-width: 768px) {
            .wrap-layout {
                flex-wrap: wrap !important; /* Force wrapping */
                overflow-x: hidden !important; /* Prevent horizontal scroll */
                min-height: 200px; /* Allow space for two rows */
                align-items: flex-start; /* Items start at the top */
                justify-content: space-evenly !important; /* Evenly space items across the width */
                padding-bottom: 0.5rem;
            }
            
            /* Items in wrap-layout should be large enough to fit 4-5 items per row without getting too small */
            .wrap-layout .item {
                flex-basis: 22%; /* Aim for 4 cards wide on most phones */
                min-width: 70px;
                max-width: 100px;
            }

            /* Hide the custom horizontal scrollbar when wrapping is active */
            .wrap-layout::-webkit-scrollbar {
                display: none;
            }
        }
        
        #reorder-list {
            display: none;
        }
        /* End Responsive Wrap CSS */
        
        /* Image styles */
        .item-icon {
            max-width: 90%; 
            max-height: 90%;
            object-fit: contain;
            position: absolute; 
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        
        /* Style for the image wrapper/fallback container */
        .item-image-wrapper {
            width: 100%; 
            height: 70px; 
            display: block;
            position: relative;
            background-color: #4b6b8b; /* Solid color fallback */
            border-radius: 4px;
        }

        .item.dragging {
            opacity: 0.8;
            transform: scale(1.1); 
            box-shadow: 0 0 15px #FF0000;
            position: absolute; 
            z-index: 1000; 
        }
        
        .item-placeholder {
            width: 75px; 
            min-height: 70px; 
            border: 3px dashed #FF6347;
            border-radius: 8px;
            margin: 0 0.5rem;
            flex: 0 0 auto;
        }

        .item.correct { background-color: #1E90FF; border-color: #FFFFFF; }
        .item.incorrect { background-color: #FF0000; border-color: #FFFFFF; }

        button {
            padding: 0.75rem 1.5rem;
            font-size: 1.1rem;
            cursor: pointer;
            border: none;
            border-radius: 5px;
            color: #ffffff;
            transition: background-color 0.3s ease, box-shadow 0.3s ease;
            font-family: 'Orbitron', sans-serif;
            font-weight: 700;
            background-color: #00BFFF;
        }
        
        .play-button {
            padding: 1.2rem 3rem; 
            font-size: 1.6rem;
            background-color: #32CD32;
            box-shadow: 0 0 15px rgba(50, 205, 50, 0.7);
        }

        .play-button:hover:not(:disabled) {
            background-color: #2cba2c;
            box-shadow: 0 0 20px rgba(50, 205, 50, 1.0);
        }
        
        .play-button:disabled {
            background-color: #4b6b8b; /* Muted color when loading */
            cursor: not-allowed;
        }

        button:hover {
            background-color: #1E90FF;
            box-shadow: 0 0 10px #00BFFF;
        }

        /* Score animation */
        .score-popup {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2.5rem; 
            font-weight: bold;
            color: #32CD32;
            animation: fade-up 1.5s forwards;
            pointer-events: none;
            text-shadow: 0 0 15px #32CD32;
            z-index: 1001;
        }

        @keyframes fade-up {
            0% { transform: translate(-50%, 0); opacity: 1; }
            100% { transform: translate(-50%, -150%); opacity: 0; }
        }
        
        /* Ensure touch devices use the grab cursor, or default to pointer */
        @media (pointer: coarse) {
            .item {
                cursor: grab;
            }
        }
    </style>
</head>
<body>

    <div class="container">
        <h1>ðŸ›’ FPG's Aisle Dash ðŸ›’</h1>
        <div id="game-info">
            <div id="lives-display"></div>
            <div id="score-display"></div>
        </div>
        <div id="game-area">
            <div id="instruction"></div>
            
            <div id="summary-text">
                <p><strong>Rules:</strong></p>
                <p>
                    1. <span class="red-bold">Memorize</span> the sequence of items in 8 seconds.
                </p>
                <p>
                    2. <span class="red-bold">Reorder</span> the scrambled items into the correct sequence by dragging and dropping in 15 seconds or less.
                </p>
                <p>
                    3. <span class="red-bold">Win</span> by reordering correctly, the faster, the more points! You have <span class="red-bold">3 lives</span>!
                </p>
            </div>
            
            <div id="timer"></div>
            <div id="item-list"></div> 
            
            <button id="start-button" class="play-button" disabled>LOADING IMAGES...</button>
            
            <div id="reorder-list"></div>
            <button id="submit-button" style="display: none;">Submit Order</button>
        </div>
    </div>

    <script>
        document.addEventListener('DOMContentLoaded', () => {

            // --- REVERTED TO PREVIOUS CLEAN IMAGE REFERENCES (Assuming files are correctly named on GitHub) ---
            const items = [
                { name: 'Milk', src: '13202316_XL1_20211008-removebg-preview.PNG' },
                { name: 'Eggs', src: '11046848_XL1-removebg-preview.PNG' },
                { name: 'Bread', src: '13218895_XL1_20220805-removebg-preview.PNG' },
                { name: 'Cheese', src: '13179364_XL1_20250128-removebg-preview.PNG' },
                { name: 'Cereal', src: '10045587_XL1_20201012-removebg-preview.PNG' },
                { name: 'Apple', src: '13242536_XL1_20251022-removebg-preview.PNG' },
                { name: 'Soap', src: '432823_XL1_20210504-removebg-preview.PNG' },
                { name: 'Coffee', src: '13267810_XL1_20250423-removebg-preview.PNG' },
                { name: 'Water', src: '13271014_XL1_20250703-removebg-preview.PNG' },
                { name: 'Potato', src: '13259518_XL1_20250217-removebg-preview.PNG' },
                { name: 'Carrot', src: '13241559_XL1_20250201-removebg-preview.PNG' },
                { name: 'Donut', src: '13227361_XL1_20221123-removebg-preview.PNG' },
            ];
            // --- END REVERTED IMAGE REFERENCES ---

            const uniqueItems = items; 

            // --- PRELOADER LOGIC: Download all images on page load ---
            function preloadImages(imageArray) {
                let loadedCount = 0;
                const totalImages = imageArray.length;
                
                return new Promise((resolve) => {
                    if (totalImages === 0) {
                        resolve();
                        return;
                    }

                    imageArray.forEach(item => {
                        const img = new Image();
                        img.onload = img.onerror = () => {
                            loadedCount++;
                            // Update button text with loading status
                            startButton.textContent = `LOADING (${loadedCount}/${totalImages})...`;
                            if (loadedCount === totalImages) {
                                resolve();
                            }
                        };
                        img.src = item.src; // Trigger the download
                    });
                });
            }
            // --- END PRELOADER LOGIC ---

            function createImageItem(item) {
                const imageWrapper = document.createElement('div');
                imageWrapper.className = 'item-image-wrapper'; 
                
                const img = document.createElement('img');
                img.src = item.src;
                img.alt = item.name;
                img.className = 'item-icon';
                
                img.onload = function() {
                    imageWrapper.appendChild(img);
                };
                
                img.onerror = function() {
                    console.warn(`Missing image file for: ${item.name} (${item.src}). Showing solid color fallback.`);
                };
                
                imageWrapper.appendChild(img);
                
                return imageWrapper;
            }


            let originalSequence = [];
            let timer;
            let currentLevel = 0;
            let totalScore = 0;
            let lives = 3;
            let startTime;
            let levelItemsCount = 3; 
            
            // Touch state variables
            let draggingItem = null;
            let placeholder = null;
            let activeList = null; 

            const FIXED_THINK_TIME_MS = 8000;
            const FIXED_ORDER_TIME_S = 15;
            const SCORE_PER_SECOND_BONUS = 5;

            const instruction = document.getElementById('instruction');
            const timerDisplay = document.getElementById('timer');
            const startButton = document.getElementById('start-button');
            const submitButton = document.getElementById('submit-button');
            const itemListContainer = document.getElementById('item-list');
            const reorderListContainer = document.getElementById('reorder-list');
            const scoreDisplay = document.getElementById('score-display');
            const livesDisplay = document.getElementById('lives-display');
            const summaryText = document.getElementById('summary-text'); 
            
            function initializeGame() {
                totalScore = 0;
                lives = 3;
                currentLevel = 0;
                levelItemsCount = 3;
                
                summaryText.style.display = 'none';
                startButton.classList.remove('play-button');
                
                reorderListContainer.style.display = 'none'; 
                itemListContainer.style.display = 'flex';
                updateDisplay();
                startGame();
            }

            function updateDisplay() {
                livesDisplay.textContent = `Lives: ${lives}`;
                scoreDisplay.textContent = `Score: ${totalScore.toFixed(0)}`;
            }

            // === NEW LOGIC: Check item count and add wrap class ===
            function toggleWrapClass(container, itemCount) {
                // If 9 or more items are required, add the wrap-layout class to trigger multi-row CSS on small screens
                // Otherwise, ensure no wrapping happens and horizontal scroll is possible.
                if (itemCount >= 9) {
                    container.classList.add('wrap-layout');
                } else {
                    container.classList.remove('wrap-layout');
                }
            }
            // =======================================================

            function startGame() {
                startButton.style.display = 'none';
                
                const levelConfig = {
                    items: levelItemsCount,
                    displayTime: FIXED_THINK_TIME_MS, 
                    sortTime: FIXED_ORDER_TIME_S
                };
                
                let selectedItems = [];

                if (startButton.textContent === 'Retry Level') {
                    selectedItems = originalSequence.map(name => 
                        uniqueItems.find(item => item.name === name)
                    );
                } else {
                    selectedItems = getRandomItems(levelConfig.items);
                    originalSequence = selectedItems.map(item => item.name);
                }
                
                // NEW: Apply wrapping class based on current level's item count
                toggleWrapClass(itemListContainer, selectedItems.length);

                displayList(selectedItems, levelConfig.displayTime);
            }

            function getRandomItems(count) {
                const shuffled = [...uniqueItems].sort(() => 0.5 - Math.random());
                return shuffled.slice(0, count);
            }
            
            function displayList(list, displayTime) {
                instruction.textContent = "Level " + (currentLevel + 1) + ": Memorize the sequence!";
                itemListContainer.innerHTML = '';
                itemListContainer.style.border = '3px dashed #00BFFF';
                
                list.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.appendChild(createImageItem(item)); 
                    itemListContainer.appendChild(itemDiv);
                });

                timerDisplay.textContent = `Time left: ${FIXED_THINK_TIME_MS / 1000}s`;
                let timeLeft = FIXED_THINK_TIME_MS / 1000;
                let displayTimer = setInterval(() => {
                    timeLeft--;
                    timerDisplay.textContent = `Time left: ${timeLeft}s`;
                    if (timeLeft <= 0) {
                        clearInterval(displayTimer);
                        startMemoryPhase(list);
                    }
                }, 1000);
            }
            
            function getGuaranteedScrambledItems(originalList) {
                let scrambledList;
                let isScrambled = false;

                if (originalList.length <= 1) {
                     return originalList; 
                }

                while (!isScrambled) {
                    scrambledList = [...originalList].sort(() => 0.5 - Math.random());
                    isScrambled = scrambledList.some((item, index) => item.name !== originalList[index].name);
                }
                return scrambledList;
            }


            function startMemoryPhase(list) {
                instruction.textContent = "Now, reorder the items!";
                itemListContainer.style.display = 'none';
                reorderListContainer.style.display = 'flex'; 
                reorderListContainer.innerHTML = '';
                reorderListContainer.style.overflowX = 'auto'; 
                
                // NEW: Apply wrapping class based on current level's item count for the reorder list
                toggleWrapClass(reorderListContainer, list.length);

                const scrambledItems = getGuaranteedScrambledItems(list);
                
                scrambledItems.forEach(item => {
                    const itemDiv = document.createElement('div');
                    itemDiv.className = 'item';
                    itemDiv.draggable = true; 
                    itemDiv.dataset.name = item.name;
                    itemDiv.appendChild(createImageItem(item)); 
                    reorderListContainer.appendChild(itemDiv);
                });

                setupDesktopDragAndDrop();
                setupTouchControls(); 
                submitButton.style.display = 'block';
                
                startTime = Date.now();
                let sortTimeLeft = FIXED_ORDER_TIME_S; 
                timerDisplay.textContent = `Sort time: ${sortTimeLeft}s`;
                timer = setInterval(() => {
                    sortTimeLeft--;
                    timerDisplay.textContent = `Sort time: ${sortTimeLeft}s`;
                    if (sortTimeLeft <= 0) {
                        clearInterval(timer);
                        checkOrder();
                    }
                }, 1000);
            }
            
            // --- DRAG AND DROP LOGIC (Unchanged) ---
            function setupDesktopDragAndDrop() {
                const listItems = document.querySelectorAll('#reorder-list .item');
                let draggingItem = null;

                listItems.forEach(item => {
                    item.addEventListener('dragstart', () => {
                        draggingItem = item;
                        setTimeout(() => item.classList.add('dragging'), 0); 
                    });

                    item.addEventListener('dragend', () => {
                        if (draggingItem) {
                            draggingItem.classList.remove('dragging');
                        }
                        draggingItem = null;
                    });
                });

                reorderListContainer.addEventListener('dragover', (e) => {
                    e.preventDefault();
                    const afterElement = getDragAfterElement(reorderListContainer, e.clientY, e.clientX); 
                    const draggable = document.querySelector('.dragging');
                    
                    if (draggable && !draggable.touchDragging) { 
                        if (afterElement == null) {
                            reorderListContainer.appendChild(draggable);
                        } else {
                            reorderListContainer.insertBefore(draggable, afterElement);
                        }
                    }
                });
            }
            
            function setupTouchControls() {
                activeList = reorderListContainer;
                const items = activeList.querySelectorAll('.item');
                
                items.forEach(item => {
                    item.removeEventListener('touchstart', handleTouchStart);
                    item.removeEventListener('touchmove', handleTouchMove);
                    item.removeEventListener('touchend', handleTouchEnd);
                    
                    item.addEventListener('touchstart', handleTouchStart, { passive: false });
                    item.addEventListener('touchmove', handleTouchMove, { passive: false });
                    item.addEventListener('touchend', handleTouchEnd);
                });
            }

            function handleTouchStart(e) {
                if (e.touches.length > 1 || draggingItem) return;
                
                e.preventDefault(); 
                
                draggingItem = e.currentTarget;
                draggingItem.classList.add('dragging');
                draggingItem.touchDragging = true; 

                placeholder = document.createElement('div');
                placeholder.className = 'item-placeholder';
                activeList.insertBefore(placeholder, draggingItem.nextSibling);

                const touch = e.touches[0];
                const rect = draggingItem.getBoundingClientRect();
                
                draggingItem.offsetX = touch.clientX - rect.left;
                draggingItem.offsetY = touch.clientY - rect.top;

                draggingItem.style.position = 'absolute';
                draggingItem.style.left = `${touch.clientX - draggingItem.offsetX}px`;
                draggingItem.style.top = `${touch.clientY - draggingItem.offsetY}px`;
                
                activeList.style.overflowX = 'hidden'; 
                activeList.style.overflowY = 'hidden'; // Prevent vertical scroll while dragging
            }

            function handleTouchMove(e) {
                if (!draggingItem || !draggingItem.touchDragging) return;
                
                e.preventDefault(); 
                
                const touch = e.touches[0];
                
                draggingItem.style.left = `${touch.clientX - draggingItem.offsetX}px`;
                draggingItem.style.top = `${touch.clientY - draggingItem.offsetY}px`;
                
                const afterElement = getDragAfterElement(activeList, touch.clientY, touch.clientX);
                
                if (afterElement == null) {
                    activeList.appendChild(placeholder);
                } else {
                    activeList.insertBefore(placeholder, afterElement);
                }
            }

            function handleTouchEnd(e) {
                if (!draggingItem || !draggingItem.touchDragging) return;

                activeList.insertBefore(draggingItem, placeholder);
                
                draggingItem.classList.remove('dragging');
                draggingItem.touchDragging = false;
                draggingItem.style.position = '';
                draggingItem.style.left = '';
                draggingItem.style.top = '';
                
                if (placeholder) {
                    placeholder.remove();
                    placeholder = null;
                }
                draggingItem = null;
                
                activeList.style.overflowX = 'auto'; 
                activeList.style.overflowY = 'auto'; 
            }
            
            function getDragAfterElement(container, y, x) {
                const draggableElements = [...container.querySelectorAll('.item:not(.dragging)')]
                    .filter(el => el !== placeholder);
                
                const closest = draggableElements.reduce((closest, child) => {
                    const rect = child.getBoundingClientRect();
                    const centerX = rect.left + rect.width / 2;
                    const distance = Math.abs(x - centerX); 

                    if (distance < closest.distance) {
                        return { distance: distance, element: child };
                    }
                    return closest;
                }, { distance: Infinity, element: null });
                
                if (closest.element === null) {
                    return null;
                }

                const child = closest.element;
                const rect = child.getBoundingClientRect();
                const itemMidX = rect.left + rect.width / 2;
                
                if (x > itemMidX) {
                    return child.nextElementSibling;
                } else {
                    return child; 
                }
            }
            // --- END DRAG AND DROP LOGIC ---


            function buildItemRow(sequence, isCorrectRow, highlightCorrect = false) {
                const rowDiv = document.createElement('div');
                rowDiv.className = 'item-list-row';

                // NEW: If item count > 8, force wrap for results display
                if (sequence.length >= 9) {
                     rowDiv.classList.add('wrap-layout');
                     // Set min-height for two rows in the results view
                     rowDiv.style.minHeight = '150px'; 
                }


                sequence.forEach((name, index) => {
                    const itemConfig = uniqueItems.find(i => i.name === name);
                    const itemDiv = document.createElement('div');
                    
                    let isItemCorrect = highlightCorrect && (name === originalSequence[index]);
                    
                    if (!isCorrectRow && highlightCorrect) {
                        itemDiv.className = `item ${isItemCorrect ? 'correct' : 'incorrect'}`;
                    } else if (isCorrectRow) {
                        itemDiv.className = 'item correct';
                    } else {
                        itemDiv.className = 'item incorrect';
                    }

                    itemDiv.appendChild(createImageItem(itemConfig));
                    rowDiv.appendChild(itemDiv);
                });
                return rowDiv;
            }


            function checkOrder() {
                clearInterval(timer);
                const endTime = Date.now();
                const timeTaken = (endTime - startTime) / 1000;
                
                const finalOrder = [...reorderListContainer.children].map(item => item.dataset.name);
                let correctCount = 0;
                
                finalOrder.forEach((item, index) => {
                    if (item === originalSequence[index]) {
                        correctCount++;
                    }
                });
                
                const items = reorderListContainer.querySelectorAll('.item');
                items.forEach(item => {
                    item.removeEventListener('touchstart', handleTouchStart);
                    item.removeEventListener('touchmove', handleTouchMove);
                    item.removeEventListener('touchend', handleTouchEnd);
                });

                submitButton.style.display = 'none';
                itemListContainer.innerHTML = '';
                reorderListContainer.style.display = 'none';

                if (correctCount === originalSequence.length) {
                    const timeBonus = Math.max(0, FIXED_ORDER_TIME_S - timeTaken);
                    const scoreThisRound = 100 + timeBonus * SCORE_PER_SECOND_BONUS;
                    totalScore += scoreThisRound;

                    updateDisplay(); 

                    instruction.className = 'feedback-title success-message';
                    instruction.textContent = "Cart Filled Successfully!";
                    timerDisplay.textContent = `Score Bonus: +${(timeBonus * SCORE_PER_SECOND_BONUS).toFixed(0)}`;
                    
                    showScorePopup(document.querySelector('.container'), "SUCCESS"); 
                    
                    setTimeout(() => {
                        itemListContainer.style.display = 'flex';
                        itemListContainer.style.border = 'none';
                        
                        const successRowContainer = document.createElement('div');
                        successRowContainer.className = 'item-list-row';
                        successRowContainer.style.gap = '0.5rem'; 

                        // NEW: Apply wrapping class based on current level's item count for success display
                        if (originalSequence.length >= 9) {
                            successRowContainer.classList.add('wrap-layout');
                            successRowContainer.style.minHeight = '150px';
                        }


                        originalSequence.forEach(name => {
                            const itemConfig = uniqueItems.find(i => i.name === name);
                            const itemDiv = document.createElement('div');
                            itemDiv.className = 'item correct';
                            itemDiv.appendChild(createImageItem(itemConfig));
                            successRowContainer.appendChild(itemDiv);
                        });
                        
                        itemListContainer.appendChild(successRowContainer);

                        if (levelItemsCount < uniqueItems.length) {
                            levelItemsCount++;
                            currentLevel++;
                            startButton.textContent = 'Next Level';
                            startButton.style.display = 'block';
                        } else {
                            instruction.textContent = "You Win! Final Score: " + totalScore.toFixed(0);
                            timerDisplay.textContent = '';
                            startButton.textContent = 'Play Again';
                            startButton.style.display = 'block';
                        }
                    }, 2000); 
                    
                } else {
                    lives--;
                    updateDisplay();
                    
                    instruction.className = 'feedback-title failure-message';
                    instruction.textContent = "Cart Filled Unsuccessfully";
                    timerDisplay.textContent = `Lives remaining: ${lives}`;
                    
                    const resultsContainer = document.createElement('div');
                    resultsContainer.className = 'results-container'; 
                    
                    // 1. YOUR CART (User's Incorrect Order)
                    const yourCartDiv = document.createElement('div');
                    yourCartDiv.className = 'result-row';
                    yourCartDiv.innerHTML = '<h3>Your Cart</h3>';
                    
                    const yourCartRow = buildItemRow(finalOrder, false, true);
                    // NEW: The buildItemRow function now handles wrapping for the rows inside the results container
                    yourCartDiv.appendChild(yourCartRow); 
                    resultsContainer.appendChild(yourCartDiv);

                    // 2. RIGHT CART (Correct Order)
                    const rightCartDiv = document.createElement('div');
                    rightCartDiv.className = 'result-row';
                    rightCartDiv.innerHTML = '<h3>Right Cart</h3>';
                    
                    const rightCartRow = buildItemRow(originalSequence, true);
                    // NEW: The buildItemRow function now handles wrapping for the rows inside the results container
                    rightCartDiv.appendChild(rightCartRow);
                    resultsContainer.appendChild(rightCartDiv);

                    itemListContainer.style.display = 'flex';
                    itemListContainer.style.border = 'none';
                    itemListContainer.appendChild(resultsContainer);
                    
                    if (lives <= 0) {
                        instruction.textContent = "Game Over!";
                        timerDisplay.textContent = `Final Score: ${totalScore.toFixed(0)}`;
                        startButton.textContent = 'Play Again';
                        startButton.style.display = 'block';
                    } else {
                        startButton.textContent = 'Retry Level';
                        startButton.style.display = 'block';
                    }
                }
            }

            function showScorePopup(element, text) {
                const popup = document.createElement('div');
                popup.className = 'score-popup';
                popup.textContent = text;
                element.appendChild(popup);

                popup.addEventListener('animationend', () => {
                    popup.remove();
                });
            }

            startButton.addEventListener('click', () => {
                instruction.className = '';
                
                startButton.classList.remove('play-button'); 

                if(startButton.textContent === 'Play Again') {
                    initializeGame();
                } else if(startButton.textContent === 'Next Level' || startButton.textContent === 'Retry Level') {
                    document.getElementById('game-area').style.opacity = '0';
                    setTimeout(() => {
                        document.getElementById('game-area').style.opacity = '1';
                        startGame();
                    }, 500);
                } else {
                    initializeGame();
                }
            });

            submitButton.addEventListener('click', checkOrder);

            // INITIALIZATION
            updateDisplay();
            instruction.textContent = "Welcome to FPG's Aisle Dash! Please wait while images load...";
            timerDisplay.textContent = '';
            
            summaryText.style.display = 'block';
            itemListContainer.style.display = 'none'; 
            reorderListContainer.style.display = 'none';
            startButton.style.display = 'block';
            
            // 1. Start Preloading
            preloadImages(uniqueItems).then(() => {
                // 2. Once loaded, enable the button
                startButton.disabled = false;
                startButton.textContent = 'PLAY';
                startButton.classList.add('play-button');
                instruction.textContent = "Welcome to FPG's Aisle Dash!";
            });

        });
    </script>
</body>
</html>
